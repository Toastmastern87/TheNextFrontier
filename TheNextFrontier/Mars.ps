Texture2D heightMapTexture : register(t0);
Texture2D heightMapDetail2Texture : register(t1);
Texture2D colorMapTexture : register(t2);
SamplerState sampleType;

struct PixelInputType
{
	float4 position : SV_POSITION;
	float4 color : COLOR;
	float2 mapCoord : TEXCOORD0;
	float3 normal : NORMAL;
	float3 viewVector : NORMAL1;
};

cbuffer LightCalculations
{
	float4 lightDirection;
	float4 diffuseColor;
	float4 patchDelta;
	matrix rotationMatrix;
};

float3x3 GetTBNMatrix(float3 normalVector, float3 posVector, float2 uv)
{
	float3 dp1, dp2, dp2perp, dp1perp, T, B;
	float2 duv1, duv2;
	float invMax;

	dp1 = ddx(posVector);
	dp2 = ddy(posVector);
	duv1 = ddx(uv);
	duv2 = ddx(uv);

	dp2perp = cross(dp2, normalVector);
	dp1perp = cross(normalVector, dp1);

	T = (dp2perp * duv1.x + dp1perp * duv2.x);
	B = (dp2perp * duv1.y + dp1perp * duv2.y);

	invMax = rsqrt(max(dot(T, T), dot(B, B)));

    return float3x3(T * invMax, B * invMax, normalVector);
}

float GetHeight(float2 uv)
{
	float2 textureStretch;

	textureStretch = float2(2.0f, 1.0f);

	return (heightMapTexture.SampleLevel(sampleType, uv, 0).r * (21.229f + 8.2f)) + (heightMapDetail2Texture.SampleLevel(sampleType, (uv * textureStretch * 700), 1).r * 1.0f);
}

float3 CalculateNormal(float3 normalVector, float3 viewVector, float2 uv)
{
	float textureWidth, textureHeight, hL, hR, hD, hU;
	float3 texOffset, N;
	float3x3 TBN;

	heightMapTexture.GetDimensions(textureWidth, textureHeight);

	texOffset = float3((1.0f / textureWidth), (1.0f / textureHeight), 0.0f);

	hL = GetHeight(uv - texOffset.xz);
	hR = GetHeight(uv + texOffset.xz);
	hD = GetHeight(uv + texOffset.zy);
	hU = GetHeight(uv - texOffset.zy);

	N = normalize(float3((hL - hR), (hU - hD), 2.0f));

	TBN = GetTBNMatrix(normalVector, -viewVector, uv);

	return mul(N, TBN);
}

float4 MarsFromSpacePixelShader(PixelInputType input) : SV_TARGET
{
	float3 normal;
	float lightIntensity, lightColor, increasedLigthningFactor;
	float4 finalColor, color;

	normal = normalize(CalculateNormal(normalize(input.normal), normalize(input.viewVector), input.mapCoord));

    lightIntensity = saturate(dot(normal, normalize(-1 * mul(lightDirection, rotationMatrix))));

    lightColor = saturate(diffuseColor * lightIntensity);

	color = colorMapTexture.SampleLevel(sampleType, input.mapCoord, 0).rgba;

	increasedLigthningFactor = 2.5f;

	return (color * increasedLigthningFactor) * lightColor;
}

float4 MarsFromAtmospherePixelShader(PixelInputType input) : SV_TARGET
{
	return float4(1.0f, 1.0f, 1.0f, 1.0f);
}
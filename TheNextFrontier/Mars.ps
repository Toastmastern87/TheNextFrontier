Texture2D shaderTexture;
SamplerState sampleType;

struct PixelInputType
{
	float4 position : SV_POSITION;
	float4 color : COLOR;
	float2 mapCoord : TEXCOORD0;
	float3 normal : NORMAL;
	float3 viewVector : NORMAL1;
};

cbuffer LightCalculations
{
	float4 lightDirection;
	float4 diffuseColor;
	float4 patchDelta;
};

float3x3 GetTBNMatrix(float3 normalVector, float3 posVector, float2 uv)
{
	float3 dp1, dp2, dp2perp, dp1perp, T, B;
	float2 duv1, duv2;
	float invMax;

	dp1 = ddx(posVector);
	dp2 = ddy(posVector);
	duv1 = ddx(uv);
	duv2 = ddx(uv);

	dp2perp = cross(dp2, normalVector);
	dp1perp = cross(normalVector, dp1);

	// * -1 due to being LH coordinate system
	T = (dp2perp * duv1.x + dp1perp * duv2.x) * -1;
	B = (dp2perp * duv1.y + dp1perp * duv2.y) * -1;

	invMax = rsqrt(max(dot(T, T), dot(B, B)));

    return float3x3(T * invMax, B * invMax, normalVector);
}

float GetHeight(float2 uv)
{
	return shaderTexture.SampleLevel(sampleType, uv, 0).r * (21.229f + 8.2f);
}

float3 CalculateNormal(float3 normalVector, float3 viewVector, float2 uv)
{
	float textureWidth, textureHeight, hL, hR, hD, hU;
	float3 texOffset, N;
	float3x3 TBN;

	shaderTexture.GetDimensions(textureWidth, textureHeight);

	texOffset = float3((1.0f / textureWidth), (1.0f / textureHeight), 0.0f);

	hL = GetHeight(uv - texOffset.xz);
	hR = GetHeight(uv + texOffset.xz);
	hD = GetHeight(uv + texOffset.zy);
	hU = GetHeight(uv - texOffset.zy);

	N = normalize(float3((hL - hR), (hU - hD), 2.0f));

	TBN = GetTBNMatrix(normalVector, -viewVector, uv);

	return mul(TBN, N);
}

float4 MarsPixelShader(PixelInputType input) : SV_TARGET
{
	float3 normal;
	float lightIntensity, color;
	float4 finalColor;

	normal = CalculateNormal(normalize(input.normal), normalize(input.viewVector), input.mapCoord);

    lightIntensity = saturate(dot(normal, normalize(-lightDirection)));

    color = saturate(diffuseColor * lightIntensity);

	return input.color;//float4(color, color, color, 1.0f);
}